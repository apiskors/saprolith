#!/bin/sh
#
# Start/stop control script for the Minecraft Bedrock Edition server.
# This runs the Mojang/Microsoft Minecraft Bedrock Server under
# screen, started via SystemD systemctl.


mc_server=mc-1
jail_dir=/data/jails/mc-1

print_help_only_p=0
while getopts hs: OPT
do
  case $OPT in
    h)  print_help_only_p=1
        ;;
    s)  mc_server=$OPTARG
        ;;
    \?)
        echo 1>&2
        echo "ERROR:  One or more bad command line options." 1>&2
        echo 1>&2
        echo "$USAGE" 1>&2
        exit 1
        ;;
  esac
done
shift `expr $OPTIND - 1`

CMDNAME=`basename $0` ; bin_dir=`dirname $0`
in_args="$@"

umask 002
base_dir="${jail_dir}/${mc_server}"
bs_bin="${base_dir}/bedrock_server"
mc_service="${mc_server}.service"


USAGE="Usage:  ${CMDNAME} [-h] [-s SERVER_NAME] CMD [CMD ...]
Description:
  This runs the Mojang/Microsoft Minecraft Bedrock Server on Linux
  under screen, preferably started via SystemD systemctl.
Options:
  -h : Show this help.
  -s  SERVER_NAME  :  Short name of server.  Currently:  $mc
      Base directory of server will be:  $base_dir
Commands:  status start stop restart
"


bad_args_exit_p=0
if [ "$print_help_only_p" -eq 1 ]
then
  bad_args_exit_p=1
  echo "$USAGE"
elif [ "$1" = "" ] ; then
  bad_args_exit_p=1
  echo "Error: You must give a at least one positional command argument." 1>&2
fi
if [ "$bad_args_exit_p" -ne 0 ] ; then exit ; fi


cd "$base_dir"
mkdir -p logs backups
#PATH="~/bin:~/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin"


# Note, I ASSUME that our Bourne shell always has SEPARATE positional
# parameter lists for individual functions vs. the whole script.  AKA,
# do not use some ancient non-Linux Bourne shell.


# Return the screen session running this mc_server, if there is one.
# If not, return empty string.
#
# Normally bedrock_server will be running as our user "mc", so for
# this to work this script MUST run as the same user.  AKA, invoke it
# with "sudo -u mc".
#
mc_screen_session() {
  local foo ; foo=$(screen -wipe 2>&1)
  # sc_sess is purposely global!
  sc_sess=`screen -list | grep "$1" | head -n 1 | awk '{print($1)}'`
}

print_running_info() {
  local f_log
  f_log=`ls -1t ${1}/logs/${2}.* | head -n 1`
  echo "Log file is probably:  $f_log"
  echo "To get to its Server console do:  screen -e^Oo -r ${2}"
  echo "Disconnect from that screen session with:  Ctrl-o d"
  echo "Of if it is a second inner screen session, disconnect with:  Ctrl-o o d"
}


# Main loop around input commands!
for arg in $in_args
do
  if [ "start" = "$arg" ] ; then
    # Call this from your SystemD *.service file.  It will also work interactively.

    mc_screen_session $mc_server  # Sets sc_sess.
    if [ "" = "$sc_sess" ] ; then running_p=0 ; else running_p=1 ; fi
    if [ 1 -eq "$running_p" ] ; then
      echo "Minecraft Server $mc_server is already running under screen!" 1>&2
      print_running_info $base_dir $mc_server
    else
      f_log="${base_dir}/logs/${mc_server}.$(date +%Y-%m-%dT%H:%M:%S).log"
      echo "Starting Minecraft Server:  $mc_server  As Linux user:  `whoami`"
      echo "Logging to file:  $f_log"
      screen -e^Oo -L -Logfile $f_log -dm -S $mc_server /bin/sh -c "LD_LIBRARY_PATH=$base_dir $bs_bin"
    fi

  elif [ "status" = "$arg" ] ; then
    mc_screen_session $mc_server  # Sets sc_sess.
    if [ "" = "$sc_sess" ] ; then running_p=0 ; else running_p=1 ; fi
    wait_pid=`echo "$sc_sess" | awk -F. '{print($1)}'`
    echo "Minecraft Server $mc_server running yes-1 or no-0:  $running_p  Shell pid:  $wait_pid"
    if [ 1 -eq "$running_p" ] ; then
      print_running_info $base_dir $mc_server
    fi

  elif [ "stop" = "$arg" ] ; then
    # Call this from your SystemD *.service file.  It will also work interactively.
    #
    # SystemD can report the tree of PIDs like this:
    #   systemctl status mc-1.service
    # But for now we will NOT use that, so that this command can work the
    # same way both under SystemD and not.

    mc_screen_session $mc_server  # Sets sc_sess.
    if [ "" = "$sc_sess" ] ; then running_p=0 ; else running_p=1 ; fi
    if [ 0 -eq "$running_p" ] ; then
      echo "Error: ${CMDNAME}: ${arg}:  Minecraft Server $mc_server is down, or NOT running under screen." 1>&2
      continue
    fi
    wait_pid=`echo "$sc_sess" | awk -F. '{print($1)}'`

    echo "Stopping Minecraft Server:  $mc_server  Child of shell pid:  $wait_pid"
    screen -Rd $mc_server -X stuff "say Stopping server right now!$(printf '\r')"
    screen -Rd $mc_server -X stuff "stop$(printf '\r')"
    running_p=1 ; ii=0
    while [ "$running_p" -eq 1 -a "$ii" -lt 20 ] ; do
      running_p=`pgrep -cg $wait_pid`
      if [ "$running_p" -eq 0 ] ; then break ; fi
      sleep 1 ; ii=$((++ii))
    done

    if [ "$running_p" -eq 1 ] ; then
      echo "Warning: Server $mc_server still running, killing screen session."
      screen -S $mc_server -X quit
    fi
    ii=0 ; while [ "$running_p" -eq 1 -a "$ii" -lt 10 ] ; do
      running_p=`pgrep -cg $wait_pid`
      if [ "$running_p" -eq 0 ] ; then break ; fi
      sleep 1 ; ii=$((++ii))
    done
    if [ "$running_p" -eq 1 ] ; then
      echo "Error: Server $mc_server still running, kill it!."
      kill $wait_pid
    fi

  elif [ "restart" = "$arg" ] ; then
    echo "TODO: ${CMDNAME}: $arg"
  elif [ "backup" = "$arg" ] ; then
    echo "TODO: ${CMDNAME}: $arg"

  elif [ "d-start" = "$arg" ] ; then
    # First install the file into /etc/systemd/system/ yourself.
    systemctl daemon-reload
    systemctl start $mc_service

  elif [ "d-stop" = "$arg" ] ; then
    systemctl stop $mc_service

  elif [ "wait-network" = "$arg" ] ; then
    dflt_gateway=$(/sbin/route -n | awk '$4 == "UG" {print $2}')
    if [ "" = "$dflt_gateway" ] ; then
      echo "Warning: ${CMDNAME}: Network is not up yet." 1>&2
      echo "TODO: Waiting not yet implemented." 1>&2
    fi

  elif [ "cmd" = "$arg" ] ; then
    # Next argument is the command to send to the running bedrock_server.
    echo "TODO: ${CMDNAME}: $arg"
  else
    echo "Error: ${CMDNAME}: Unknown command argument:  $arg" 1>&2
  fi
done
